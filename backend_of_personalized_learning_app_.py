# -*- coding: utf-8 -*-
"""backend of personalized  learning app .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q-w4UV0l0zT9m9-0X5BfS5UX1cb_lPtl

**sign in /sign up session**
"""

import re

def check_password(password):
  """
  Checks if the password meets criteria and prints the criteria.
    - At least 8 characters long
    - At least one uppercase letter
    - At least one lowercase letter
    - At least one number
    - At least one symbol
  """
  print("Password criteria:")
  print("- At least 8 characters long")
  print("- At least one uppercase letter")
  print("- At least one lowercase letter")
  print("- At least one number")
  print("- At least one symbol")

  if len(password) < 8:
    return False
  if not re.search("[a-z]", password):
    return False
  if not re.search("[A-Z]", password):
    return False
  if not re.search("[0-9]", password):
    return False
  if not re.search("[!@#$%^&*()_+=[\]{};':\"\\|,.<>/?]", password):
    return False
  return True

def sign_up():
  """
  Prompts user for email, confirms email, and password.
  Checks password and simulates storing user data.
  """
  while True:
    email = input("Enter your email: ")
    confirm_email = input("Confirm your email: ")
    if email != confirm_email:
      print("Emails do not match. Please try again.")
    else:
      break

  while True:
    password = input("Enter your password: ")
    if check_password(password):
      print("Sign up successful!")
      # In a real application, you would store the email and password securely
      break
    else:
      print("Password does not meet the criteria. Please try again.")

def sign_in():
  """
  Prompts user for email and password, checks password against
  simulated stored data.
  """
  email = input("Enter your email: ")
  password = input("Enter your password: ")
  # In a real application, you would retrieve the stored password for the given email
  # and compare it with the entered password
  if check_password(password):  # This is just a placeholder for actual authentication
    print("Sign in successful!")
  else:
    print("Invalid email or password.")

while True:
  """
  Provides a simple menu for user to choose sign up or sign in.
  """

  choice = input("Do you want to sign up (1) or sign in (2)? ")
  if choice == '1':
    sign_up()
    break
  elif choice == '2':
    sign_in()
    break
  else:
    print("Invalid choice. Please enter 1 or 2.")

"""LEARNIGN STYLe
> Add blockquote


"""

questions = [
    "I prefer to learn by...",
    "When trying to understand something new, I find it most helpful to...",
    "I remember information best when I...",
    "If I had to explain a complex topic to someone, I would...",
    "When solving a problem, I tend to...",
]

options = [
    "a) Watching demonstrations or videos (Visual)",
    "b) Listening to explanations and discussions (Auditory)",
    "c) Reading and writing about it (Read/Write)",
    "d) Doing hands-on activities or experiments (Kinesthetic)"
]

responses = []
for question in questions:
  print(question)
  for option in options:
    print(option)
  response = input("Enter your answer (a, b, c, or d): ")
  responses.append(response)

def analyze_responses(responses):
  # Implement logic to analyze responses and determine learning style
  # Example: Count occurrences of each option and assign learning style
  # based on majority.
  visual = responses.count('a')
  auditory = responses.count('b')
  read_write = responses.count('c')
  kinesthetic = responses.count('d')

  if visual > auditory and visual > read_write and visual > kinesthetic:
    return "Visual"
  elif auditory > visual and auditory > read_write and auditory > kinesthetic:
    return "Auditory"
  elif read_write > visual and read_write > auditory and read_write > kinesthetic:
    return "Read/Write"
  # Add more conditions for other learning styles
  else:
    return "Kinesthetic" # This is a placeholder, add more conditions


learning_style = analyze_responses(responses)
print(f"Your learning style is likely: {learning_style}")

# Define the learning_style_info function before calling it
def learning_style_info(style):
  if style=="Visual":
    description="I prefer to learn by watching demonstrations or videos."
    techniques = "Try using visual aids like mind maps, diagrams, flashcards with pictures, and color-coding your notes. Watch videos and demonstrations related to your studies."
  elif style=="Auditory":
    description="I prefer to learn by listening to explanations and discussions."
    techniques = "Try recording lectures and listening to them later, explaining concepts to others, participating in discussions, and using mnemonics or rhymes to remember information."
  elif style == "Read/Write":
    description = "Read/Write learners prefer to learn through reading and writing. They benefit from textbooks, articles, and taking notes."
    techniques = "Try taking detailed notes, rewriting notes in your own words, reading textbooks and articles, and creating summaries or outlines of the material."
  elif style == "Kinesthetic":
    description = "Kinesthetic learners prefer to learn through hands-on experiences and movement. They benefit from experiments, simulations, and practical activities."
    techniques = "Try using hands-on activities, building models, role-playing, and finding real-world examples or applications of what you're learning."
  else:
    description = "It seems like you have a mixed learning style. You can benefit from a variety of techniques."
    techniques = "Experiment with different techniques from each learning style to find what works best for you. Don't be afraid to combine methods and try new things."
  return description, techniques

# Call the learning_style_info function after it has been defined
description, techniques = learning_style_info(learning_style)

print(f"Your learning style is likely: {learning_style}")
print(f"\n{description}")
print(f"\nHere are some study techniques that might be helpful for you:\n{techniques}")

"""**MODEL TRAINIG**"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

career=pd.read_csv('/content/career_recommender.csv')
career.head()

career.isnull().sum()

career = career.rename(columns={
    'What is your name?': 'name',
    'What is your gender?': 'gender',
    'What was your course in UG?': 'course',
    'What is your UG specialization? Major Subject (Eg; Mathematics)': 'specialization',
    'What are your interests?': 'interests',
    'What are your skills ? (Select multiple if necessary)': 'skills',
    'What was the average CGPA or Percentage obtained in under graduation?': 'cgpa',
    'Did you do any certification courses additionally?': 'certifications',
    'If yes, please specify your certificate course title.': 'certificate_course_title',
    'Are you working?': 'working',
    'If yes, then what is/was your first Job title in your current field of work? If not applicable, write NA.               ': 'first_job_title',
    'Have you done masters after undergraduation? If yes, mention your field of masters.(Eg; Masters in Mathematics)': 'masters_field'
})

print(career.columns)

#lets deal with the missing values and replace them with unkown
career['masters_field'] = career['masters_field'].fillna('Unknown')
career['first_job_title'] = career['first_job_title'].fillna('Unknown')
career['certificate_course_title'] = career['certificate_course_title'].fillna('Unknown')
career['skills'] = career['skills'].fillna('Unknown')

career.isnull().sum()

#lets check for the duplicates
duplicates = career[career.duplicated()]
print(duplicates)
num_duplicates = duplicates.shape[0]
print(f"Number of duplicate rows: {num_duplicates}")

import matplotlib.pyplot as plt

course_counts = career['course'].value_counts()
plt.bar(course_counts.index, course_counts.values)
plt.xlabel("Course")
plt.ylabel("Frequency")
plt.title("Distribution of Courses")
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()



# lets train the model since tumemaliza with exploration and cleanng. we are training the SKILL reccomendation model
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# 1. Data Preparation:
# Select relevant features and target variable
X = career[['interests', 'course', 'specialization']]  # Features for skills prediction
y = career['skills']  # Target variable: skills

# 2. Data Splitting:
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 3. Feature Engineering:
# Convert text features to numerical representations using TF-IDF
vectorizer = TfidfVectorizer()
X_train_tfidf = vectorizer.fit_transform(X_train['interests'] + ' ' + X_train['course'] + ' ' + X_train['specialization'])
X_test_tfidf = vectorizer.transform(X_test['interests'] + ' ' + X_test['course'] + ' ' + X_test['specialization'])

# 4. Model Training (Cosine Similarity):
# Calculate cosine similarity between feature vectors
similarity_matrix = cosine_similarity(X_train_tfidf)

# 5. Recommendation Function:
def recommend_skills(user_interests, user_course, user_specialization, top_n=5):
    user_features = vectorizer.transform([user_interests + ' ' + user_course + ' ' + user_specialization])
    similarities = cosine_similarity(user_features, X_train_tfidf)
    sorted_indices = similarities.argsort()[0][-top_n:]
    recommended_skills = y_train.iloc[sorted_indices].tolist()
    return recommended_skills

# 6. Example Usage:
user_interests = "Machine Learning, Data Science"
user_course = "Computer Science"
user_specialization = "Artificial Intelligence"
recommendations = recommend_skills(user_interests, user_course, user_specialization)
print(recommendations)



# sincetumetrain the skill lets train the career recomendation model
career['career_features'] = (career['skills'] * 2) + ' ' + career['interests'] + ' ' + career['specialization'] + ' ' + career['certificate_course_title'] + ' ' + career['masters_field']

career_vectorizer = TfidfVectorizer()
career_vectorizer.fit(career['career_features'])  # Assuming 'career_features' is your combined feature column
X_career_tfidf = career_vectorizer.transform(career['career_features'])

def recommend_careers(skills, interests, specialization, certificate, masters='Unknown', top_n=5, threshold=0.5):
    user_features = career_vectorizer.transform([f"{skills} {interests} {specialization} {certificate} {masters}"])
    similarities = cosine_similarity(user_features, X_career_tfidf)

    # Filter recommendations based on threshold
    filtered_indices = [i for i, sim in enumerate(similarities[0]) if sim >= threshold]

    # Get top N recommendations from filtered indices
    sorted_indices = similarities[0][filtered_indices].argsort()[-top_n:]
    recommended_careers = career['first_job_title'].iloc[sorted_indices].tolist()

    return recommended_careers
# Function to recommend careers (assuming X_career_tfidf and career_vectorizer are already defined)
def recommend_careers(skills, interests, specialization, certificate, masters='Unknown', top_n=5):
    user_features = career_vectorizer.transform([f"{skills} {interests} {specialization} {certificate} {masters}"])
    similarities = cosine_similarity(user_features, X_career_tfidf)
    sorted_indices = similarities.argsort()[0][-top_n:]
    recommended_careers = career['first_job_title'].iloc[sorted_indices].tolist()
    return recommended_careers

# Example usage for medical data
recommendations = recommend_careers(
    skills="Python, Java, Machine Learning",
    interests="Software Development, Artificial Intelligence",
    specialization="Computer Science",
    certificate="AWS Certified Developer",
    masters="Masters in Computer Science"
)
print(recommendations)

# we arenow getting the user input

# Handle missing values
for column in ['interests', 'course', 'specialization', 'skills', 'certificate_course_title', 'masters_field']:
    career[column] = career[column].fillna('')

# Create 'combined_features_skill' for skill recommendations
career['combined_features_skill'] = career['interests'] + ' ' + career['course'] + ' ' + career['specialization']

# Create 'combined_features' for career recommendations
career['combined_features'] = career['skills'] + ' ' + career['interests'] + ' ' + career['specialization'] + ' ' + career['certificate_course_title'] + ' ' + career['masters_field']

# Create and fit the vectorizer for skill recommendation
skill_vectorizer = TfidfVectorizer()
skill_vectorizer.fit(career['combined_features_skill'])
X_train_tfidf = skill_vectorizer.transform(career['combined_features_skill'])
y_train = career['skills']

# Create and fit the vectorizer for career recommendation
career_vectorizer = TfidfVectorizer()
career_vectorizer.fit(career['combined_features'])
X_career_tfidf = career_vectorizer.transform(career['combined_features'])

# Function to recommend skills
def recommend_skills(user_interests, user_course, user_specialization, top_n=5):
    try:
        user_features = skill_vectorizer.transform([user_interests + ' ' + user_course + ' ' + user_specialization])
        similarities = cosine_similarity(user_features, X_train_tfidf)
        sorted_indices = similarities.argsort()[0][-top_n:]
        recommended_skills = y_train.iloc[sorted_indices].tolist()
        return recommended_skills
    except:
        return []

# Function to recommend careers
def recommend_careers(skills, interests, specialization, certificate, masters='Unknown', top_n=5):
    try:
        user_features = career_vectorizer.transform([f"{skills} {interests} {specialization} {certificate} {masters}"])
        similarities = cosine_similarity(user_features, X_career_tfidf)
        sorted_indices = similarities.argsort()[0][-top_n:]
        recommended_careers = career['first_job_title'].iloc[sorted_indices].tolist()
        return recommended_careers
    except:
        return []

# Function to get user input for skill recommendations
def get_skill_input():
    print("For Skill Recommendations:")
    user_interests = input("Enter your interests (comma-separated): ")
    user_course = input("Enter your course: ")
    user_specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
    return user_interests, user_course, user_specialization

# Function to get user input for career recommendations
def get_career_input():
    print("\nFor Career Recommendations:")
    skills = input("Enter your skills (comma-separated): ")
    interests = input("Enter your interests (comma-separated): ")
    specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
    certificate = input("Enter your certificate course title (if any): ")
    masters = input("Enter your masters field (if any): ")
    return skills, interests, specialization, certificate, masters

# Function to provide recommendations
def provide_recommendations(recommendations, recommendation_type):
    print(f"\nRecommended {recommendation_type}:")
    if recommendations:
        for recommendation in recommendations:
            print(recommendation)
    else:
        print(f"No {recommendation_type} recommendations found.")

# Main execution
if __name__ == "__main__":
    # Ask the user about their uncertainty
    uncertainty = input("Are you unsure about your skills or career? (Enter 'skills' or 'career'): ").lower()

    if uncertainty == 'skills':
        # Get input and provide skill recommendations
        user_interests_skill, user_course, user_specialization = get_skill_input()
        skill_recommendations = recommend_skills(user_interests_skill, user_course, user_specialization)
        provide_recommendations(skill_recommendations, "Skills")
    elif uncertainty == 'career':
        # Get input and provide career recommendations
        skills_career, interests_career, specialization_career, certificate, masters = get_career_input()
        career_recommendations = recommend_careers(skills_career, interests_career, specialization_career, certificate, masters)
        provide_recommendations(career_recommendations, "Careers")
    else:
        print("Invalid input. Please enter 'skills' or 'career'.")



"""import the neccesary models and load the model

"""

import pickle

# Save the trained models to pickle files
with open('skill_recommendation_model.pkl', 'wb') as file:
    pickle.dump(skill_vectorizer, file)  # Changed skill_model to skill_vectorizer

with open('career_recommendation_model.pkl', 'wb') as file:
    pickle.dump(career_vectorizer, file)  # Changed career_model to career_vectorizer

# download the files
from google.colab import files
files.download('skill_recommendation_model.pkl')
files.download('career_recommendation_model.pkl')

import pickle
from sklearn.metrics import accuracy_score

# Load the saved models
with open('skill_recommendation_model.pkl', 'rb') as file:
    skill_vectorizer = pickle.load(file)

with open('career_recommendation_model.pkl', 'rb') as file:
    career_vectorizer = pickle.load(file)

# Assuming 'y_train' from your recommendation code is the actual skill labels
y_skill = y_train

# Define 'skill_predictions' using the loaded 'skill_vectorizer' and 'recommend_skills' function
skill_predictions = [recommend_skills(interests, course, specialization)[0] for interests, course, specialization in zip(career['interests'], career['course'], career['specialization'])]

# Define 'career_predictions' using the loaded 'career_vectorizer' and 'recommend_careers' function
career_predictions = [recommend_careers(skills, interests, specialization, certificate, masters)[0] for skills, interests, specialization, certificate, masters in zip(career['skills'], career['interests'], career['specialization'], career['certificate_course_title'], career['masters_field'])]
y_career = career['first_job_title']

skill_accuracy = accuracy_score(y_skill, skill_predictions)  # Now using the defined y_skill
career_accuracy = accuracy_score(y_career, career_predictions)  # Now using the defined y_career

print(f"Skill Recommendation Accuracy: {skill_accuracy}")
print(f"Career Recommendation Accuracy: {career_accuracy}")

"""The improvements we've made aim to move beyond simple keyword matching and leverage the semantic understanding of words through word embeddings. This, combined with careful preprocessing, a simpler model to avoid overfitting, and better feature engineering, should contribute to an increase in the accuracy of the recommendation system.

"""



!pip install gensim

import nltk
import pickle
import gensim.downloader
from nltk.stem import WordNetLemmatizer
from nltk.corpus import stopwords
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import accuracy_score

# Download NLTK resources
nltk.download('wordnet')
nltk.download('stopwords')
nltk.download('punkt')

# Load Word2Vec embeddings
print("Loading word embeddings...")
glove_vectors = gensim.downloader.load('glove-wiki-gigaword-100')
print("Word embeddings loaded.")

def preprocess_text(text):
    text = text.lower()
    tokens = nltk.word_tokenize(text)
    lemmatizer = WordNetLemmatizer()
    tokens = [lemmatizer.lemmatize(token) for token in tokens if token not in stopwords.words('english') and token.isalnum()] # Removing non-alphanumeric tokens
    return tokens

def get_text_embedding(text_tokens):
    """Get the average embedding for a list of tokens."""
    embeddings = [glove_vectors[token] for token in text_tokens if token in glove_vectors]
    if embeddings:
        return sum(embeddings) / len(embeddings)
    else:
        return [0] * glove_vectors.vector_size  # Return a zero vector if no embeddings found



# Feature Engineering and Preprocessing
career['combined_features_skill'] = career['interests'] + ' ' + career['course'] + ' ' + career['specialization']
career['combined_features_career'] = career['skills'] + ' ' + career['interests'] + ' ' + career['specialization'] + ' ' + career['certificate_course_title'] + ' ' + career['masters_field']

career['combined_features_skill_tokens'] = career['combined_features_skill'].apply(preprocess_text)
career['combined_features_career_tokens'] = career['combined_features_career'].apply(preprocess_text)

# Get embeddings for combined features
career['combined_features_skill_embedding'] = career['combined_features_skill_tokens'].apply(get_text_embedding)
career['combined_features_career_embedding'] = career['combined_features_career_tokens'].apply(get_text_embedding)

# Recommendation Functions (using cosine similarity with embeddings)
def recommend_skills(user_interests, user_course, user_specialization, top_n=5):
    user_text = user_interests + ' ' + user_course + ' ' + user_specialization
    user_tokens = preprocess_text(user_text)
    user_embedding = get_text_embedding(user_tokens)

    similarities = career['combined_features_skill_embedding'].apply(lambda x: cosine_similarity([user_embedding], [x])[0][0])
    sorted_indices = similarities.argsort()[-top_n:][::-1]  # Get top_n most similar indices
    recommended_skills = career['skills'].iloc[sorted_indices].tolist()
    return recommended_skills

def recommend_careers(skills, interests, specialization, certificate, masters='Unknown', top_n=5):
    user_text = f"{skills} {interests} {specialization} {certificate} {masters}"
    user_tokens = preprocess_text(user_text)
    user_embedding = get_text_embedding(user_tokens)

    similarities = career['combined_features_career_embedding'].apply(lambda x: cosine_similarity([user_embedding], [x])[0][0])
    sorted_indices = similarities.argsort()[-top_n:][::-1]  # Get top_n most similar indices
    recommended_careers = career['first_job_title'].iloc[sorted_indices].tolist()
    return recommended_careers
# Calculate accuracy
skill_predictions = [recommend_skills(interests, course, specialization)[0]
                     for interests, course, specialization in zip(career['interests'], career['course'], career['specialization'])]
career_predictions = [recommend_careers(skills, interests, specialization, certificate, masters)[0]
                     for skills, interests, specialization, certificate, masters in
                     zip(career['skills'], career['interests'], career['specialization'], career['certificate_course_title'], career['masters_field'])]

skill_accuracy = accuracy_score(career['skills'], skill_predictions)
career_accuracy = accuracy_score(career['first_job_title'], career_predictions)

print(f"Skill Recommendation Accuracy: {skill_accuracy}")
print(f"Career Recommendation Accuracy: {career_accuracy}")

import pickle
import nltk
from nltk.stem import WordNetLemmatizer
from nltk.corpus import stopwords
from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd
import numpy as np

# Load the models and embeddings
with open('skill_recommendation_model.pkl', 'rb') as f:
    skill_vectorizer = pickle.load(f)
with open('career_recommendation_model.pkl', 'rb') as f:
    career_vectorizer = pickle.load(f)
with open('glove_embeddings.pkl', 'rb') as f:
    glove_vectors = pickle.load(f)

# Download NLTK resources if not already downloaded
nltk.download('wordnet')
nltk.download('stopwords')
nltk.download('punkt')

def preprocess_text(text):
    text = text.lower()
    tokens = nltk.word_tokenize(text)
    lemmatizer = WordNetLemmatizer()
    tokens = [lemmatizer.lemmatize(token) for token in tokens if token not in stopwords.words('english') and token.isalnum()]
    return tokens

def get_text_embedding(text_tokens, glove_vectors):
    embeddings = [glove_vectors[token] for token in text_tokens if token in glove_vectors]
    if embeddings:
        return np.mean(embeddings, axis=0)
    else:
        return np.zeros(glove_vectors.vector_size)

def recommend_skills(user_interests, user_course, user_specialization, top_n=5):
    user_text = user_interests + ' ' + user_course + ' ' + user_specialization
    user_tokens = preprocess_text(user_text)
    user_embedding = get_text_embedding(user_tokens, glove_vectors)
    similarities = career['combined_features_skill_embedding'].apply(
        lambda x: cosine_similarity([user_embedding], [x])[0][0] if isinstance(x, np.ndarray) else 0)
    sorted_indices = similarities.argsort()[-top_n:][::-1]
    recommended_skills = career['skills'].iloc[sorted_indices].tolist()
    return recommended_skills

def recommend_careers(skills, interests, specialization, certificate, masters='Unknown', top_n=5):
    user_text = f"{skills} {interests} {specialization} {certificate} {masters}"
    user_tokens = preprocess_text(user_text)
    user_embedding = get_text_embedding(user_tokens, glove_vectors)
    similarities = career['combined_features_career_embedding'].apply(
        lambda x: cosine_similarity([user_embedding], [x])[0][0] if isinstance(x, np.ndarray) else 0)
    sorted_indices = similarities.argsort()[-top_n:][::-1]
    recommended_careers = career['first_job_title'].iloc[sorted_indices].tolist()
    return recommended_careers

def get_user_input():
    while True:
        recommendation_type = input("Do you want recommendations for skills or career? (Enter 'skills' or 'career'): ").lower()
        if recommendation_type in ['skills', 'career']:
            break
        else:
            print("Invalid input. Please enter 'skills' or 'career'.")

    if recommendation_type == 'skills':
        user_interests = input("Enter your interests (comma-separated): ")
        user_course = input("Enter your course: ")
        user_specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
        return recommendation_type, user_interests, user_course, user_specialization
    else:  # recommendation_type == 'career'
        skills = input("Enter your skills (comma-separated): ")
        interests = input("Enter your interests (comma-separated): ")
        specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
        certificate = input("Enter your certificate course title (if any): ")
        masters = input("Enter your masters field (if any): ")
        return recommendation_type, skills, interests, specialization, certificate, masters
for recommendation in recommendations:
 print(recommendation)

"""import pickle
import nltk
from nltk.stem import WordNetLemmatizer
from nltk.corpus import stopwords
from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd
import numpy as np

# Load the models and embeddings
with open('skill_recommendation_model.pkl', 'rb') as f:
    skill_vectorizer = pickle.load(f)
with open('career_recommendation_model.pkl', 'rb') as f:
    career_vectorizer = pickle.load(f)
with open('glove_embeddings.pkl', 'rb') as f:
    glove_vectors = pickle.load(f)

# Download NLTK resources if not already downloaded
nltk.download('wordnet')
nltk.download('stopwords')
nltk.download('punkt')

# Assuming you have career DataFrame loaded with embeddings in another cell

def preprocess_text(text):
    text = text.lower()
    tokens = nltk.word_tokenize(text)
    lemmatizer = WordNetLemmatizer()
    tokens = [lemmatizer.lemmatize(token) for token in tokens if token not in stopwords.words('english') and token.isalnum()]
    return tokens

def get_text_embedding(text_tokens, glove_vectors):
    embeddings = [glove_vectors[token] for token in text_tokens if token in glove_vectors]
    if embeddings:
        return np.mean(embeddings, axis=0)  # Calculate average embedding
    else:
        return np.zeros(glove_vectors.vector_size)  # Return zero vector if no embeddings found

def recommend_skills(user_interests, user_course, user_specialization, top_n=5):
    user_text = user_interests + ' ' + user_course + ' ' + user_specialization
    user_tokens = preprocess_text(user_text)
    user_embedding = get_text_embedding(user_tokens, glove_vectors)

    # Access the embeddings from the 'career' DataFrame
    similarities = career['combined_features_skill_embedding'].apply(
        lambda x: cosine_similarity([user_embedding], [x])[0][0] if isinstance(x, np.ndarray) else 0)

    # Sort by similarity and get the top_n indices
    sorted_indices = similarities.argsort()[-top_n:][::-1]

    # Get the recommended skills from the 'career' DataFrame using the indices
    recommended_skills = career['skills'].iloc[sorted_indices].tolist()

    return recommended_skills

def recommend_careers(skills, interests, specialization, certificate, masters='Unknown', top_n=5):
    user_text = f"{skills} {interests} {specialization} {certificate} {masters}"
    user_tokens = preprocess_text(user_text)
    user_embedding = get_text_embedding(user_tokens, glove_vectors)

    # Access the embeddings from the 'career' DataFrame
    similarities = career['combined_features_career_embedding'].apply(
        lambda x: cosine_similarity([user_embedding], [x])[0][0] if isinstance(x, np.ndarray) else 0)

    # Sort by similarity and get the top_n indices
    sorted_indices = similarities.argsort()[-top_n:][::-1]

    # Get the recommended careers from the 'career' DataFrame using the indices
    recommended_careers = career['first_job_title'].iloc[sorted_indices].tolist()

    return recommended_careers

# ... (Your existing imports and functions) ...

def get_user_input():
    while True:
        recommendation_type = input("Do you want recommendations for skills or career? (Enter 'skills' or 'career'): ").lower()
        if recommendation_type in ['skills', 'career']:
            break
        else:
            print("Invalid input. Please enter 'skills' or 'career'.")

    if recommendation_type == 'skills':
        user_interests = input("Enter your interests (comma-separated): ")
        user_course = input("Enter your course: ")
        user_specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
        return recommendation_type, user_interests, user_course, user_specialization
    else:  # recommendation_type == 'career'
        skills = input("Enter your skills (comma-separated): ")
        interests = input("Enter your interests (comma-separated): ")
        specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
        certificate = input("Enter your certificate course title (if any): ")
        masters = input("Enter your masters field (if any): ")
        return recommendation_type, skills, interests, specialization, certificate, masters

def main():
    # No need to reload or clean data, as 'career' is already available

    # Get user input:
    recommendation_type, *user_inputs = get_user_input()  

    if recommendation_type == 'skills':
        user_interests, user_course, user_specialization = user_inputs
        recommendations = recommend_skills(user_interests, user_course, user_specialization)
        print("\nSkill Recommendations:")
    else:  # recommendation_type == 'career'
        skills, interests, specialization, certificate, masters = user_inputs
        recommendations = recommend_careers(skills, interests, specialization, certificate, masters)
        print("\nCareer Recommendations:")

    for recommendation in recommendations:
        print(recommendation)
# ... (Your existing imports and functions) ...

def get_user_input():
    while True:
        recommendation_type = input("Do you want recommendations for skills or career? (Enter 'skills' or 'career'): ").lower()
        if recommendation_type in ['skills', 'career']:
            break
        else:
            print("Invalid input. Please enter 'skills' or 'career'.")

    if recommendation_type == 'skills':
        user_interests = input("Enter your interests (comma-separated): ")
        user_course = input("Enter your course: ")
        user_specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
        return recommendation_type, user_interests, user_course, user_specialization
    else:  # recommendation_type == 'career'
        skills = input("Enter your skills (comma-separated): ")
        interests = input("Enter your interests (comma-separated): ")
        specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
        certificate = input("Enter your certificate course title (if any): ")
        masters = input("Enter your masters field (if any): ")
        return recommendation_type, skills, interests, specialization, certificate, masters

def main():
    # No need to reload or clean data, as 'career' is already available

    # Get user input:
    recommendation_type, *user_inputs = get_user_input()  

    if recommendation_type == 'skills':
        user_interests, user_course, user_specialization = user_inputs
        recommendations = recommend_skills(user_interests, user_course, user_specialization)
        print("\nSkill Recommendations:")
    else:  # recommendation_type == 'career'
        skills, interests, specialization, certificate, masters = user_inputs
        recommendations = recommend_careers(skills, interests, specialization, certificate, masters)
        print("\nCareer Recommendations:")

    for recommendation in recommendations:
        print(recommendation)

if __name__ == "__main__":
    main()

"""

import pickle

   # ... (After retraining) ...

   # Save the skill recommendation model
with open('skill_recommendation_model.pkl', 'wb') as f:
       pickle.dump(skill_vectorizer, f)  # If you refitted skill_vectorizer

   # Save the career recommendation model
with open('career_recommendation_model.pkl', 'wb') as f:
       pickle.dump(career_vectorizer, f)  # If you refitted career_vectorizer

   # Save the GloVe embeddings
with open('glove_embeddings.pkl', 'wb') as f:
       pickle.dump(glove_vectors, f)

def train_models_main():
    # ... (Your model training code for skills and career recommendations)
    return skill_model, career_model



from google.colab import files

# Download the skill recommendation model
files.download('skill_recommendation_model.pkl')

# Download the career recommendation model
files.download('career_recommendation_model.pkl')

# Download the GloVe embeddings
files.download('glove_embeddings.pkl')



"""fileorganization

"""

from google.colab import files
import os

def create_study_folders(num_units):
  """Creates folders and subfolders for each unit, including unit name and code, and allows file uploads."""
  for unit in range(1, num_units + 1):
    unit_name = input(f"Enter the name of Unit {unit}: ")
    unit_code = input(f"Enter the code for Unit {unit}: ")
    while True:
      folder_name_choice = input("Use unit name (1) or code (2) for folder name? ")
      if folder_name_choice == '1':
        unit_folder = f"Unit {unit} - {unit_name}"
        break
      elif folder_name_choice == '2':
        unit_folder = f"Unit {unit} - {unit_code}"
        break
      else:
        print("Invalid choice. Please enter 1 or 2.")
    os.makedirs(unit_folder, exist_ok=True)

    subfolders = ["Exams", "Notes", "Possible Questions"]
    for subfolder in subfolders:
      os.makedirs(os.path.join(unit_folder, subfolder), exist_ok=True)

    while True:  # Loop for uploading files to the current unit
        uploaded = files.upload()  # Use files.upload() to get files from the user
        if not uploaded:  # If no files were uploaded, break the loop
            break
        for filename, data in uploaded.items():
            while True:
                subfolder_choice = input(f"Choose subfolder for '{filename}' (Exams, Notes, Possible Questions): ").capitalize()
                if subfolder_choice in subfolders:
                    destination = os.path.join(unit_folder, subfolder_choice, filename)
                    with open(destination, 'wb') as f:
                        f.write(data)
                    print(f"File '{filename}' uploaded to {destination}")
                    break
                else:
                    print("Invalid subfolder choice.")

        more_files = input("Upload more files to this unit? (yes/no): ").lower()
        if more_files != 'yes':
            break

  print("Study folders created successfully!")
if __name__ == "__main__":
    # Get the number of units from the user
    num_units = int(input("Enter the number of units: "))
    # Call the create_study_folders function directly
    create_study_folders(num_units)



"""timer ya study"""

import time
import threading

def pomodoro_timer_background(study_time, cycles):
    """
    Implements a Pomodoro timer with customizable study duration and cycles,
    running in a background thread.

    Args:
        study_time (int): The desired study duration in minutes (25-60).
        cycles (int): The number of Pomodoro cycles to complete.
    """

    if not 25 <= study_time <= 60:
        print("Invalid study time. Please choose between 25 and 60 minutes.")
        return

    if cycles < 1:
        print("Invalid number of cycles. Please choose at least 1 cycle.")
        return

    for i in range(cycles):
        print(f"\nStarting Pomodoro cycle {i + 1} of {cycles}...")
        pomodoro_timer_single_cycle(study_time)
        if i < cycles - 1:  # Don't take a long break after the last cycle
            print("Take a 5-minute short break.")
            time.sleep(300)  # 5 minutes in seconds

    print("\nAll Pomodoro cycles completed! Take a longer break.")

def pomodoro_timer_single_cycle(study_time):
    """
    Runs a single Pomodoro cycle with the given study duration.
    """
    print(f"Starting Pomodoro timer for {study_time} minutes...")

    # Convert study time to seconds
    study_time_seconds = study_time * 60

    # Start the timer
    start_time = time.time()
    end_time = start_time + study_time_seconds

    # Display the remaining time
    while time.time() < end_time:
        remaining_time = int(end_time - time.time())
        minutes = remaining_time // 60
        seconds = remaining_time % 60
        print(f"Time remaining: {minutes:02d}:{seconds:02d}", end="\r")
        time.sleep(1)

    print("\nTime's up for this cycle!")

# Get user input
study_time = int(input("Enter study duration (25-60 minutes): "))
cycles = int(input("Enter number of Pomodoro cycles: "))

# Create and start the timer thread
timer_thread = threading.Thread(target=pomodoro_timer_background, args=(study_time, cycles))
timer_thread.start()

print("Timer started in the background. You can run other cells now.")





!pip install schedule==1.1.0
import pandas as pd
import matplotlib.pyplot as plt
import datetime
import ast
import schedule
import time
import threading

class ProgressTracker:
    def __init__(self):
        self.tasks_completed = 0
        self.total_study_time = 0

    def track_task(self, duration):
        self.tasks_completed += 1
        self.total_study_time += duration

class User:
    def __init__(self, username):
        self.username = username
        self.study_time = 0
        self.badges = []
        self.points = 0
        self.weekly_plan = []  # List to store StudyPlan objects
        self.progress_tracker = ProgressTracker()  # Create ProgressTracker instance for user

    class StudyPlan:  # StudyPlan defined inside the User class
        def __init__(self, user, task, subject, day, time, duration, notes=""):
            self.user = user
            self.task = task
            self.subject = subject
            self.day = day
            self.time = time
            self.duration = duration
            self.notes = notes
            self.completed = False

        def mark_complete(self):
            self.completed = True
            self.user.progress_tracker.track_task(self.duration) # Update progress tracker

    def add_task_to_plan(self, task, subject, day, time, duration, notes=""):
        # Access StudyPlan using self.StudyPlan since it's an inner class
        study_plan = self.StudyPlan(self, task, subject, day, time, duration, notes)
        self.weekly_plan.append(study_plan)
        # Schedule reminder (using schedule library)
        # Note: Ensure 'schedule' is imported and available
        schedule.every().day.at(time).do(self.send_reminder, study_plan=study_plan)  # Pass study_plan as keyword argument

    def send_reminder(self, study_plan=None):
        if study_plan:
            print(f"Reminder: {study_plan.task} for {study_plan.subject} at {study_plan.time}")
        else:
            print("Reminder: No study plan provided.")

def run_scheduler():
    while True:
        schedule.run_pending()
        time.sleep(1)

# Create and start the scheduler thread
scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
scheduler_thread.start()

# --- Your Background Tasks ---

# Replace this with your actual background tasks and schedule them using 'schedule.every()'
def my_background_task():
    print("Running my background task...")
    # ... your task logic ...

schedule.every(5).seconds.do(my_background_task)  # Example: Run every 5 seconds

!pip install schedule==1.1.0
import pandas as pd
import matplotlib.pyplot as plt
import datetime
import ast
import schedule
import time
import threading

# ... (Your existing ProgressTracker, User, and StudyPlan classes) ...

def run_scheduler():
    while True:
        schedule.run_pending()
        time.sleep(1)

# Create and start the scheduler thread
scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
scheduler_thread.start()

# --- Your Background Tasks ---

def check_for_updates():
    """
    This task could check for updates from a server or database.
    """
    print("Checking for updates...")
    # ... your update logic ...

def process_data():
    """
    This task could process data files or perform calculations.
    """
    print("Processing data...")
    # ... your data processing logic ...

def send_notifications():
    """
    This task could send email or other notifications.
    """
    print("Sending notifications...")
    # ... your notification logic ...

# Schedule the tasks
schedule.every(10).minutes.do(check_for_updates)
schedule.every().hour.do(process_data)
schedule.every().day.at("10:00").do(send_notifications)

# --- End of Your Background Tasks ---

# Your script can continue with other operations or exit here
print("Background tasks scheduled. Script continuing...")
# Your script can continue with other operations or exit here
print("Background tasks scheduled. Script continuing...")



"""grades prediction model

"""

import zipfile

with zipfile.ZipFile('/content/archive (3).zip', 'r') as zip_ref:
    zip_ref.extractall('.')

grades=pd.read_csv('/content/student_performance.csv')

grades.head()

grades.isnull().sum()



# Find all duplicate rows
duplicates = grades[grades.duplicated()]

print(duplicates)

# Get the number of duplicate rows
num_duplicates = duplicates.shape[0]
print(f"Number of duplicate rows: {num_duplicates}")

grades.info()

print(grades.columns)

import matplotlib.pyplot as plt

plt.scatter(grades['AttendanceRate'], grades['FinalGrade'])
plt.xlabel('Attendance Rate')
plt.ylabel('Final Grade')
plt.title('Scatter Plot of Attendance Rate vs. Final Grade')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

sns.regplot(x='AttendanceRate', y='FinalGrade', data=grades)
plt.xlabel('Attendance Rate')
plt.ylabel('Final Grade')
plt.title('Scatter Plot with Regression Line')
plt.show()

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_squared_error


# Select features and target variable
features = ['AttendanceRate', 'StudyHoursPerWeek', 'PreviousGrade', 'ExtracurricularActivities']
X = grades[features]
y = grades['FinalGrade']

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create and train the model
grades_prediction_model = LinearRegression()
grades_prediction_model.fit(X_train, y_train)

# Make predictions on the test set
predictions = grades_prediction_model.predict(X_test)

# Evaluate the model
accuracy = r2_score(y_test, predictions)
mse = mean_squared_error(y_test, predictions)

print(f"Accuracy (R-squared): {accuracy}")
print(f"Mean Squared Error: {mse}")



# Get user input for features
attendance_rate = float(input("Enter Attendance Rate (0-100): "))
study_hours = float(input("Enter Study Hours Per Week: "))
previous_grade = float(input("Enter Previous Grade (0-100) , if you do not have the previous grades use the cat marks and change them to percentage: "))
extracurricular_activities = int(input("Enter Extracurricular Activities (0 for No, 1 for Yes): "))

# Create a DataFrame for user input
user_input = pd.DataFrame([[attendance_rate, study_hours, previous_grade, extracurricular_activities]], columns=features)

# Make prediction for user input
# ... (previous code) ...

# Make prediction for user input
prediction = grades_prediction_model.predict(user_input)[0]

# Motivational messages and study tips based on predicted grade
if prediction < 60:
    print("Your predicted grade is a bit low. But don't give up on studying!")
    print("With more effort and focused study, you can definitely improve and pass.")
    print("Here are some study tips that might help:")
    print("- Break down your study sessions into smaller, manageable chunks.")
    print("- Create a study schedule and stick to it.")
    print("- Find a quiet and distraction-free study environment.")
    print("- Actively engage with the material by taking notes, asking questions, and practicing problems.")

elif prediction >= 60 and prediction < 80:
    print("Your predicted grade is good, but there's always room for improvement!")
    print("Keep up the good work and strive for even better results.")
    print("Here are some tips to enhance your learning:")
    print("- Review your notes regularly and identify areas where you need more practice.")
    print("- Seek clarification from your teachers or classmates if you have any doubts.")
    print("- Utilize different learning resources like textbooks, online tutorials, and practice quizzes.")
    print("- Collaborate with peers for group study sessions and discussions.")

else:  # prediction >= 80
    print("Excellent! Your predicted grade is outstanding.")
    print("Keep up the fantastic work and continue to challenge yourself.")
    print("Here are some tips to maintain your high performance:")
    print("- Stay organized and manage your time effectively.")
    print("- Seek out advanced learning opportunities and explore topics in greater depth.")
    print("- Participate in extracurricular activities that align with your interests.")
    print("- Don't be afraid to ask for help or guidance when needed.")

print(f"Predicted Final Grade: {prediction:.2f}")

!pip install joblib==1.3.2
import joblib
# Create and train the model
grades_prediction_model = LinearRegression()
grades_prediction_model.fit(X_train, y_train)

# Save the trained model
joblib.dump(grades_prediction_model, 'grades_prediction_model.pkl')



"""reminders"""

import random
import time
import datetime

def daily_reminder():
    """
    Sends a daily reminder with motivational quotes and messages
    in the morning and evening.
    """

    quotes = [
        "The only way to do great work is to love what you do. - Steve Jobs",
        "Believe you can and you're halfway there. - Theodore Roosevelt",
        "The difference between ordinary and extraordinary is that little extra. - Jimmy Johnson",
        "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
        "Success is not final, failure is not fatal: it is the courage to continue that counts. - Winston Churchill",
        "Don't be afraid to give up the good to go for the great. - John D. Rockefeller",
        "The mind is everything. What you think you become. - Buddha",
        "The only person you are destined to become is the person you decide to be. - Ralph Waldo Emerson",
        "Life is 10% what happens to me and 90% of how I react to it. - Charles Swindoll",
        "The only thing that stands between you and your dream is the will to try and the belief that it is actually possible. - Joel Brown"
    ]

    messages = [
        "Remember to take breaks and stay hydrated during your study sessions.",
        "Don't be afraid to ask for help if you're struggling with a concept.",
        "Celebrate your small victories and stay motivated!",
        "Believe in yourself and your ability to succeed.",
        "You've got this! Keep pushing towards your goals."
    ]

    # Get the current time
    now = datetime.datetime.now()

    # Check if it's 8:00 AM or 8:00 PM (you can adjust the times)
    if (now.hour == 8 and now.minute == 0) or \
        (now.hour == 20 and now.minute == 0):  # 20 represents 8:00 PM

        # Indent the following lines to be part of the if block
        quote = random.choice(quotes)
        message = random.choice(messages)

        # Print the reminder
        print("\n--- Daily Reminder ---")
        print(quote)
        print(message)
        print("Don't give up on your dreams! Keep studying and you'll achieve them.")
        print("---\n")



"""dash board"""

import pandas as pd
import matplotlib.pyplot as plt
import datetime
import ast

class ProgressTracker:
    def __init__(self, data_file="progress_data.csv"):
        self.data_file = data_file
        try:
            # Check if the file exists and is not empty
            self.df = pd.read_csv(data_file, index_col="Date", parse_dates=True)
        except (FileNotFoundError, pd.errors.EmptyDataError):
            # If the file doesn't exist or is empty, create a new DataFrame
            self.df = pd.DataFrame(columns=["Task", "Completed"])
            # Create a Date column and set it as the index
            self.df['Date'] = pd.to_datetime([])  # Initialize as empty DatetimeIndex
            self.df.set_index('Date', inplace=True)
        except (pd.errors.ParserError, ValueError):
            # If the file has data but 'Date' column is missing or has an invalid format
            # Create an empty DataFrame
            print("Error reading the CSV file. Creating a new empty DataFrame.")
            self.df = pd.DataFrame(columns=["Task", "Completed"])
            self.df['Date'] = pd.to_datetime([])  # Initialize as empty DatetimeIndex
            self.df.set_index('Date', inplace=True)
            # Note: Consider logging or reporting the specific parsing error here for debugging

    def _convert_to_list(self, value):
        """Converts a value to a list if it's not already a list."""
        if isinstance(value, list):
            return value
        try:
            # Attempt to evaluate as a literal list
            return ast.literal_eval(value)
        except (SyntaxError, ValueError):
            # If evaluation fails, treat as a single string task
            return [value] if pd.notna(value) else []  # Convert to list if not NaN, else return empty list

    def add_task(self, task, completed=False):
        today = pd.Timestamp(datetime.date.today())  # Use pandas Timestamp
        if today not in self.df.index:
            self.df.loc[today, ["Task", "Completed"]] = [[task], completed]  # Store task as list
        else:
            # Append to existing task list
            existing_tasks = self.df.loc[today, "Task"]
            if isinstance(existing_tasks, list):
                existing_tasks.append(task)
            else:
                existing_tasks = [existing_tasks, task]  # Convert to list if needed
            self.df.loc[today, ["Task", "Completed"]] = [existing_tasks, completed]
            self.df.loc[today, "Completed"] = completed or self.df.loc[today, "Completed"]
        self.save_data()

    def mark_complete(self, date, task):
        date_ts = pd.Timestamp(date)
        if date_ts in self.df.index:
            tasks = self.df.loc[date_ts, "Task"]
            if isinstance(tasks, list) and task in tasks:
                tasks.remove(task)  # Remove the task if found
                self.df.loc[date_ts, ["Task", "Completed"]] = [tasks, True]
            else:
                print(f"Task '{task}' not found for date {date}")
        else:
            print(f"Date {date} not found in progress data.")
        self.save_data()

    def calculate_streak(self):
        self.df['Completed'] = self.df['Completed'].astype(bool)
        streaks = self.df['Completed'].groupby((self.df['Completed'] != self.df['Completed'].shift()).cumsum()).transform('size') * self.df['Completed']
        current_streak = streaks.iloc[-1] if not streaks.empty else 0  # Handle empty streaks
        return current_streak

    def visualize_progress(self):
        daily_completed = self.df["Completed"].astype(int).resample("D").sum()
        streak_data = self.df['Completed'].groupby((self.df['Completed'] != self.df['Completed'].shift()).cumsum()).transform('size')

    def visualize_progress(self):
        daily_completed = self.df["Completed"].astype(int).resample("D").sum()
        streak_data = self.df['Completed'].groupby((self.df['Completed'] != self.df['Completed'].shift()).cumsum()).transform('size') * self.df['Completed']

        fig, ax1 = plt.subplots(figsize=(10, 5))
        ax1.plot(daily_completed.index, daily_completed.values, marker='o', color='blue', label="Daily Completed Tasks")
        ax1.set_xlabel("Date")
        ax1.set_ylabel("Completed Tasks", color='blue')
        ax1.tick_params('y', labelcolor='blue')
        ax2 = ax1.twinx()
        ax2.plot(streak_data.index, streak_data.values, marker='x', color='red', label="Current Streak")
        ax2.set_ylabel("Streak (Days)", color='red')
        ax2.tick_params('y', labelcolor='red')

        plt.title("Daily Task Completion and Streak")
        fig.legend(loc="upper left")

        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()

        print(f"Current Streak: {self.calculate_streak()} days")

def save_data(self):
        # Convert 'Task' column to string representation of lists before saving
        self.df['Task'] = self.df['Task'].apply(lambda x: str(x) if isinstance(x, list) else x)
        self.df.to_csv(self.data_file, index=True)



"""study room

"""

class User:
    def __init__(self, username):
        self.username = username
        self.study_time = 0
        self.badges = []
        self.points = 0

class StudySession:
    def __init__(self, room_name, duration):
        self.room_name = room_name
        self.duration = duration
        self.participants = []

    def add_participant(self, user):
        self.participants.append(user)

    def end_session(self):
        for user in self.participants:
            user.study_time += self.duration
            # Award points based on study time
            user.points += self.duration * 10  # Example: 10 points per minute
            # Check for badge achievements
            if self.duration >= 60:  # Example: Award "Focus Master" badge for 60+ minutes
                user.badges.append("Focus Master")

# Leaderboard Logic (simplified):
def update_leaderboard(users):
    leaderboard = sorted(users, key=lambda user: user.study_time, reverse=True)



"""shedular"""



nything

import os
import time
import threading
import schedule
import getpass
import pandas as pd
from google.colab import output
output.eval_js('new Promise(resolve => setTimeout(resolve, 1000));') # optional to keep Colab connection alive.
MODEL_PATH = "models/"
DATA_PATH = "data/"
# --- Sign-up/Sign-in ---
import re

def check_password(password):
  """
  Checks if the password meets criteria and prints the criteria.
    - At least 8 characters long
    - At least one uppercase letter
    - At least one lowercase letter
    - At least one number
    - At least one symbol
  """
  print("Password criteria:")
  print("- At least 8 characters long")
  print("- At least one uppercase letter")
  print("- At least one lowercase letter")
  print("- At least one number")
  print("- At least one symbol")

  if len(password) < 8:
    return False
  if not re.search("[a-z]", password):
    return False
  if not re.search("[A-Z]", password):
    return False
  if not re.search("[0-9]", password):
    return False
  if not re.search("[!@#$%^&*()_+=[\]{};':\"\\|,.<>/?]", password):
    return False
  return True

def sign_up():
  """
  Prompts user for email, confirms email, and password.
  Checks password and simulates storing user data.
  """
  while True:
    email = input("Enter your email: ")
    confirm_email = input("Confirm your email: ")
    if email != confirm_email:
      print("Emails do not match. Please try again.")
    else:
      break

  while True:
    password = input("Enter your password: ")
    if check_password(password):
      print("Sign up successful!")
      # In a real application, you would store the email and password securely
      break
    else:
      print("Password does not meet the criteria. Please try again.")

def sign_in():
  """
  Prompts user for email and password, checks password against
  simulated stored data.
  """
  email = input("Enter your email: ")
  password = input("Enter your password: ")
  # In a real application, you would retrieve the stored password for the given email
  # and compare it with the entered password
  if check_password(password):  # This is just a placeholder for actual authentication
    print("Sign in successful!")
  else:
    print("Invalid email or password.")

while True:
  """
  Provides a simple menu for user to choose sign up or sign in.
  """

  choice = input("Do you want to sign up (1) or sign in (2)? ")
  if choice == '1':
    sign_up()
    break
  elif choice == '2':
    sign_in()
    break
  else:
    print("Invalid choice. Please enter 1 or 2.")

# --- Learning Style Questionnaire ---
def conduct_quiz(user):
  questions = [
    "I prefer to learn by...",
    "When trying to understand something new, I find it most helpful to...",
    "I remember information best when I...",
    "If I had to explain a complex topic to someone, I would...",
    "When solving a problem, I tend to...",
]

options = [
    "a) Watching demonstrations or videos (Visual)",
    "b) Listening to explanations and discussions (Auditory)",
    "c) Reading and writing about it (Read/Write)",
    "d) Doing hands-on activities or experiments (Kinesthetic)"
]

responses = []
for question in questions:
  print(question)
  for option in options:
    print(option)
  response = input("Enter your answer (a, b, c, or d): ")
  responses.append(response)

def analyze_responses(responses):
  # Implement logic to analyze responses and determine learning style
  # Example: Count occurrences of each option and assign learning style
  # based on majority.
  visual = responses.count('a')
  auditory = responses.count('b')
  read_write = responses.count('c')
  kinesthetic = responses.count('d')

  if visual > auditory and visual > read_write and visual > kinesthetic:
    return "Visual"
  elif auditory > visual and auditory > read_write and auditory > kinesthetic:
    return "Auditory"
  elif read_write > visual and read_write > auditory and read_write > kinesthetic:
    return "Read/Write"
  # Add more conditions for other learning styles
  else:
    return "Kinesthetic" # This is a placeholder, add more conditions


learning_style = analyze_responses(responses)
print(f"Your learning style is likely: {learning_style}")

# Define the learning_style_info function before calling it
def learning_style_info(style):
  if style=="Visual":
    description="I prefer to learn by watching demonstrations or videos."
    techniques = "Try using visual aids like mind maps, diagrams, flashcards with pictures, and color-coding your notes. Watch videos and demonstrations related to your studies."
  elif style=="Auditory":
    description="I prefer to learn by listening to explanations and discussions."
    techniques = "Try recording lectures and listening to them later, explaining concepts to others, participating in discussions, and using mnemonics or rhymes to remember information."
  elif style == "Read/Write":
    description = "Read/Write learners prefer to learn through reading and writing. They benefit from textbooks, articles, and taking notes."
    techniques = "Try taking detailed notes, rewriting notes in your own words, reading textbooks and articles, and creating summaries or outlines of the material."
  elif style == "Kinesthetic":
    description = "Kinesthetic learners prefer to learn through hands-on experiences and movement. They benefit from experiments, simulations, and practical activities."
    techniques = "Try using hands-on activities, building models, role-playing, and finding real-world examples or applications of what you're learning."
  else:
    description = "It seems like you have a mixed learning style. You can benefit from a variety of techniques."
    techniques = "Experiment with different techniques from each learning style to find what works best for you. Don't be afraid to combine methods and try new things."
  return description, techniques

# Call the learning_style_info function after it has been defined
description, techniques = learning_style_info(learning_style)

print(f"Your learning style is likely: {learning_style}")
print(f"\n{description}")
print(f"\nHere are some study techniques that might be helpful for you:\n{techniques}")

pass  # Add this line to provide an indented block within the function


# --- Career and Skill Recommendation ---
def recommend_skills(field, subfield):
 import pickle
 import nltk
 from nltk.stem import WordNetLemmatizer
 from nltk.corpus import stopwords
 from sklearn.metrics.pairwise import cosine_similarity
 import pandas as pd
 import numpy as np

# Load the models and embeddings
with open('skill_recommendation_model.pkl', 'rb') as f:
    skill_vectorizer = pickle.load(f)
with open('career_recommendation_model.pkl', 'rb') as f:
    career_vectorizer = pickle.load(f)
with open('glove_embeddings.pkl', 'rb') as f:
    glove_vectors = pickle.load(f)

# Download NLTK resources if not already downloaded
nltk.download('wordnet')
nltk.download('stopwords')
nltk.download('punkt')

def preprocess_text(text):
    text = text.lower()
    tokens = nltk.word_tokenize(text)
    lemmatizer = WordNetLemmatizer()
    tokens = [lemmatizer.lemmatize(token) for token in tokens if token not in stopwords.words('english') and token.isalnum()]
    return tokens

def get_text_embedding(text_tokens, glove_vectors):
    embeddings = [glove_vectors[token] for token in text_tokens if token in glove_vectors]
    if embeddings:
        return np.mean(embeddings, axis=0)
    else:
        return np.zeros(glove_vectors.vector_size)

def recommend_skills(user_interests, user_course, user_specialization, top_n=5):
    user_text = user_interests + ' ' + user_course + ' ' + user_specialization
    user_tokens = preprocess_text(user_text)
    user_embedding = get_text_embedding(user_tokens, glove_vectors)
    similarities = career['combined_features_skill_embedding'].apply(
        lambda x: cosine_similarity([user_embedding], [x])[0][0] if isinstance(x, np.ndarray) else 0)
    sorted_indices = similarities.argsort()[-top_n:][::-1]
    recommended_skills = career['skills'].iloc[sorted_indices].tolist()
    return recommended_skills

def recommend_careers(skills, interests, specialization, certificate, masters='Unknown', top_n=5):
    user_text = f"{skills} {interests} {specialization} {certificate} {masters}"
    user_tokens = preprocess_text(user_text)
    user_embedding = get_text_embedding(user_tokens, glove_vectors)
    similarities = career['combined_features_career_embedding'].apply(
        lambda x: cosine_similarity([user_embedding], [x])[0][0] if isinstance(x, np.ndarray) else 0)
    sorted_indices = similarities.argsort()[-top_n:][::-1]
    recommended_careers = career['first_job_title'].iloc[sorted_indices].tolist()
    return recommended_careers

def get_user_input():
    while True:
        recommendation_type = input("Do you want recommendations for skills or career? (Enter 'skills' or 'career'): ").lower()
        if recommendation_type in ['skills', 'career']:
            break
        else:
            print("Invalid input. Please enter 'skills' or 'career'.")

    if recommendation_type == 'skills':
        user_interests = input("Enter your interests (comma-separated): ")
        user_course = input("Enter your course: ")
        user_specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
        return recommendation_type, user_interests, user_course, user_specialization
    else:  # recommendation_type == 'career'
        skills = input("Enter your skills (comma-separated): ")
        interests = input("Enter your interests (comma-separated): ")
        specialization = input("Enter your specialization (e.g., Artificial Intelligence): ")
        certificate = input("Enter your certificate course title (if any): ")
        masters = input("Enter your masters field (if any): ")
        return recommendation_type, skills, interests, specialization, certificate, masters
for recommendation in recommendations:
 print(recommendation)

pass  # Adding this for consistency

# --- File Organizer ---
def create_study_folders(num_units):
 from google.colab import files

def create_study_folders(num_units):
  """Creates folders and subfolders for each unit, including unit name and code, and allows file uploads."""
  for unit in range(1, num_units + 1):
    unit_name = input(f"Enter the name of Unit {unit}: ")
    unit_code = input(f"Enter the code for Unit {unit}: ")
    while True:
      folder_name_choice = input("Use unit name (1) or code (2) for folder name? ")
      if folder_name_choice == '1':
        unit_folder = f"Unit {unit} - {unit_name}"
        break
      elif folder_name_choice == '2':
        unit_folder = f"Unit {unit} - {unit_code}"
        break
      else:
        print("Invalid choice. Please enter 1 or 2.")
    os.makedirs(unit_folder, exist_ok=True)

    subfolders = ["Exams", "Notes", "Possible Questions"]
    for subfolder in subfolders:
      os.makedirs(os.path.join(unit_folder, subfolder), exist_ok=True)

    while True:  # Loop for uploading files to the current unit
        uploaded = files.upload()  # Use files.upload() to get files from the user
        if not uploaded:  # If no files were uploaded, break the loop
            break
        for filename, data in uploaded.items():
            while True:
                subfolder_choice = input(f"Choose subfolder for '{filename}' (Exams, Notes, Possible Questions): ").capitalize()
                if subfolder_choice in subfolders:
                    destination = os.path.join(unit_folder, subfolder_choice, filename)
                    with open(destination, 'wb') as f:
                        f.write(data)
                    print(f"File '{filename}' uploaded to {destination}")
                    break
                else:
                    print("Invalid subfolder choice.")

        more_files = input("Upload more files to this unit? (yes/no): ").lower()
        if more_files != 'yes':
            break

  print("Study folders created successfully!")
if __name__ == "__main__":
    # Get the number of units from the user
    num_units = int(input("Enter the number of units: "))
    # Call the create_study_folders function directly
    create_study_folders(num_units)

pass  # Adding this for consistency





def run_schedule_in_background():
 !pip install schedule==1.1.0
 import pandas as pd
 import matplotlib.pyplot as plt
 import datetime
 import ast
 import schedule
 import time
 import threading

class ProgressTracker:
    def __init__(self):
        self.tasks_completed = 0
        self.total_study_time = 0

    def track_task(self, duration):
        self.tasks_completed += 1
        self.total_study_time += duration

class User:
    def __init__(self, username):
        self.username = username
        self.study_time = 0
        self.badges = []
        self.points = 0
        self.weekly_plan = []  # List to store StudyPlan objects
        self.progress_tracker = ProgressTracker()  # Create ProgressTracker instance for user

    class StudyPlan:  # StudyPlan defined inside the User class
        def __init__(self, user, task, subject, day, time, duration, notes=""):
            self.user = user
            self.task = task
            self.subject = subject
            self.day = day
            self.time = time
            self.duration = duration
            self.notes = notes
            self.completed = False

        def mark_complete(self):
            self.completed = True
            self.user.progress_tracker.track_task(self.duration) # Update progress tracker

    def add_task_to_plan(self, task, subject, day, time, duration, notes=""):
        # Access StudyPlan using self.StudyPlan since it's an inner class
        study_plan = self.StudyPlan(self, task, subject, day, time, duration, notes)
        self.weekly_plan.append(study_plan)
        # Schedule reminder (using schedule library)
        # Note: Ensure 'schedule' is imported and available
        schedule.every().day.at(time).do(self.send_reminder, study_plan=study_plan)  # Pass study_plan as keyword argument

    def send_reminder(self, study_plan=None):
        if study_plan:
            print(f"Reminder: {study_plan.task} for {study_plan.subject} at {study_plan.time}")
        else:
            print("Reminder: No study plan provided.")

def run_scheduler():
    while True:
        schedule.run_pending()
        time.sleep(1)

# Create and start the scheduler thread
scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
scheduler_thread.start()

# --- Your Background Tasks ---

# Replace this with your actual background tasks and schedule them using 'schedule.every()'
def my_background_task():
    print("Running my background task...")
    # ... your task logic ...

schedule.every(5).seconds.do(my_background_task)  # Example: Run every 5 seconds

!pip install schedule==1.1.0
import pandas as pd
import matplotlib.pyplot as plt
import datetime
import ast
import schedule
import time
import threading

# ... (Your existing ProgressTracker, User, and StudyPlan classes) ...

def run_scheduler():
    while True:
        schedule.run_pending()
        time.sleep(1)

# Create and start the scheduler thread
scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
scheduler_thread.start()

# --- Your Background Tasks ---

def check_for_updates():
    """
    This task could check for updates from a server or database.
    """
    print("Checking for updates...")
    # ... your update logic ...

def process_data():
    """
    This task could process data files or perform calculations.
    """
    print("Processing data...")
    # ... your data processing logic ...

def send_notifications():
    """
    This task could send email or other notifications.
    """
    print("Sending notifications...")
    # ... your notification logic ...

# Schedule the tasks
schedule.every(10).minutes.do(check_for_updates)
schedule.every().hour.do(process_data)
schedule.every().day.at("10:00").do(send_notifications)

# --- End of Your Background Tasks ---

# Your script can continue with other operations or exit here
print("Background tasks scheduled. Script continuing...")
# Your script can continue with other operations or exit here
print("Background tasks scheduled. Script continuing...")      # Adding this for consistency
pass  # Adding this for consistency
# --- Timer ---
def start_timer(user):
 import time
 import threading

def pomodoro_timer_background(study_time, cycles):
    """
    Implements a Pomodoro timer with customizable study duration and cycles,
    running in a background thread.

    Args:
        study_time (int): The desired study duration in minutes (25-60).
        cycles (int): The number of Pomodoro cycles to complete.
    """

    if not 25 <= study_time <= 60:
        print("Invalid study time. Please choose between 25 and 60 minutes.")
        return

    if cycles < 1:
        print("Invalid number of cycles. Please choose at least 1 cycle.")
        return

    for i in range(cycles):
        print(f"\nStarting Pomodoro cycle {i + 1} of {cycles}...")
        pomodoro_timer_single_cycle(study_time)
        if i < cycles - 1:  # Don't take a long break after the last cycle
            print("Take a 5-minute short break.")
            time.sleep(300)  # 5 minutes in seconds

    print("\nAll Pomodoro cycles completed! Take a longer break.")

def pomodoro_timer_single_cycle(study_time):
    """
    Runs a single Pomodoro cycle with the given study duration.
    """
    print(f"Starting Pomodoro timer for {study_time} minutes...")

    # Convert study time to seconds
    study_time_seconds = study_time * 60

    # Start the timer
    start_time = time.time()
    end_time = start_time + study_time_seconds

    # Display the remaining time
    while time.time() < end_time:
        remaining_time = int(end_time - time.time())
        minutes = remaining_time // 60
        seconds = remaining_time % 60
        print(f"Time remaining: {minutes:02d}:{seconds:02d}", end="\r")
        time.sleep(1)

    print("\nTime's up for this cycle!")

# Get user input
study_time = int(input("Enter study duration (25-60 minutes): "))
cycles = int(input("Enter number of Pomodoro cycles: "))

# Create and start the timer thread
timer_thread = threading.Thread(target=pomodoro_timer_background, args=(study_time, cycles))
timer_thread.start()

print("Timer started in the background. You can run other cells now.")

pass  # Adding this for consistency

# --- Grades Prediction ---
def predict_grades(user):

# Get user input for features
 attendance_rate = float(input("Enter Attendance Rate (0-100): "))
 study_hours = float(input("Enter Study Hours Per Week: "))
 previous_grade = float(input("Enter Previous Grade (0-100) , if you do not have the previous grades use the cat marks and change them to percentage: "))
 extracurricular_activities = int(input("Enter Extracurricular Activities (0 for No, 1 for Yes): "))

# Create a DataFrame for user input
user_input = pd.DataFrame([[attendance_rate, study_hours, previous_grade, extracurricular_activities]], columns=features)

# Make prediction for user input
# ... (previous code) ...

# Make prediction for user input
prediction = grades_prediction_model.predict(user_input)[0]

# Motivational messages and study tips based on predicted grade
if prediction < 60:
    print("Your predicted grade is a bit low. But don't give up on studying!")
    print("With more effort and focused study, you can definitely improve and pass.")
    print("Here are some study tips that might help:")
    print("- Break down your study sessions into smaller, manageable chunks.")
    print("- Create a study schedule and stick to it.")
    print("- Find a quiet and distraction-free study environment.")
    print("- Actively engage with the material by taking notes, asking questions, and practicing problems.")

elif prediction >= 60 and prediction < 80:
    print("Your predicted grade is good, but there's always room for improvement!")
    print("Keep up the good work and strive for even better results.")
    print("Here are some tips to enhance your learning:")
    print("- Review your notes regularly and identify areas where you need more practice.")
    print("- Seek clarification from your teachers or classmates if you have any doubts.")
    print("- Utilize different learning resources like textbooks, online tutorials, and practice quizzes.")
    print("- Collaborate with peers for group study sessions and discussions.")

else:  # prediction >= 80
    print("Excellent! Your predicted grade is outstanding.")
    print("Keep up the fantastic work and continue to challenge yourself.")
    print("Here are some tips to maintain your high performance:")
    print("- Stay organized and manage your time effectively.")
    print("- Seek out advanced learning opportunities and explore topics in greater depth.")
    print("- Participate in extracurricular activities that align with your interests.")
    print("- Don't be afraid to ask for help or guidance when needed.")

print(f"Predicted Final Grade: {prediction:.2f}")
pass  # Adding this for consistency

# --- Dashboard ---
def display_dashboard(user):
 import pandas as pd
 import matplotlib.pyplot as plt
 import datetime
 import ast

class ProgressTracker:
    def __init__(self, data_file="progress_data.csv"):
        self.data_file = data_file
        try:
            # Check if the file exists and is not empty
            self.df = pd.read_csv(data_file, index_col="Date", parse_dates=True)
        except (FileNotFoundError, pd.errors.EmptyDataError):
            # If the file doesn't exist or is empty, create a new DataFrame
            self.df = pd.DataFrame(columns=["Task", "Completed"])
            # Create a Date column and set it as the index
            self.df['Date'] = pd.to_datetime([])  # Initialize as empty DatetimeIndex
            self.df.set_index('Date', inplace=True)
        except (pd.errors.ParserError, ValueError):
            # If the file has data but 'Date' column is missing or has an invalid format
            # Create an empty DataFrame
            print("Error reading the CSV file. Creating a new empty DataFrame.")
            self.df = pd.DataFrame(columns=["Task", "Completed"])
            self.df['Date'] = pd.to_datetime([])  # Initialize as empty DatetimeIndex
            self.df.set_index('Date', inplace=True)
            # Note: Consider logging or reporting the specific parsing error here for debugging

    def _convert_to_list(self, value):
        """Converts a value to a list if it's not already a list."""
        if isinstance(value, list):
            return value
        try:
            # Attempt to evaluate as a literal list
            return ast.literal_eval(value)
        except (SyntaxError, ValueError):
            # If evaluation fails, treat as a single string task
            return [value] if pd.notna(value) else []  # Convert to list if not NaN, else return empty list

    def add_task(self, task, completed=False):
        today = pd.Timestamp(datetime.date.today())  # Use pandas Timestamp
        if today not in self.df.index:
            self.df.loc[today, ["Task", "Completed"]] = [[task], completed]  # Store task as list
        else:
            # Append to existing task list
            existing_tasks = self.df.loc[today, "Task"]
            if isinstance(existing_tasks, list):
                existing_tasks.append(task)
            else:
                existing_tasks = [existing_tasks, task]  # Convert to list if needed
            self.df.loc[today, ["Task", "Completed"]] = [existing_tasks, completed]
            self.df.loc[today, "Completed"] = completed or self.df.loc[today, "Completed"]
        self.save_data()

    def mark_complete(self, date, task):
        date_ts = pd.Timestamp(date)
        if date_ts in self.df.index:
            tasks = self.df.loc[date_ts, "Task"]
            if isinstance(tasks, list) and task in tasks:
                tasks.remove(task)  # Remove the task if found
                self.df.loc[date_ts, ["Task", "Completed"]] = [tasks, True]
            else:
                print(f"Task '{task}' not found for date {date}")
        else:
            print(f"Date {date} not found in progress data.")
        self.save_data()

    def calculate_streak(self):
        self.df['Completed'] = self.df['Completed'].astype(bool)
        streaks = self.df['Completed'].groupby((self.df['Completed'] != self.df['Completed'].shift()).cumsum()).transform('size') * self.df['Completed']
        current_streak = streaks.iloc[-1] if not streaks.empty else 0  # Handle empty streaks
        return current_streak

    def visualize_progress(self):
        daily_completed = self.df["Completed"].astype(int).resample("D").sum()
        streak_data = self.df['Completed'].groupby((self.df['Completed'] != self.df['Completed'].shift()).cumsum()).transform('size')

    def visualize_progress(self):
        daily_completed = self.df["Completed"].astype(int).resample("D").sum()
        streak_data = self.df['Completed'].groupby((self.df['Completed'] != self.df['Completed'].shift()).cumsum()).transform('size') * self.df['Completed']

        fig, ax1 = plt.subplots(figsize=(10, 5))
        ax1.plot(daily_completed.index, daily_completed.values, marker='o', color='blue', label="Daily Completed Tasks")
        ax1.set_xlabel("Date")
        ax1.set_ylabel("Completed Tasks", color='blue')
        ax1.tick_params('y', labelcolor='blue')
        ax2 = ax1.twinx()
        ax2.plot(streak_data.index, streak_data.values, marker='x', color='red', label="Current Streak")
        ax2.set_ylabel("Streak (Days)", color='red')
        ax2.tick_params('y', labelcolor='red')

        plt.title("Daily Task Completion and Streak")
        fig.legend(loc="upper left")

        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()

        print(f"Current Streak: {self.calculate_streak()} days")

def save_data(self):
        # Convert 'Task' column to string representation of lists before saving
        self.df['Task'] = self.df['Task'].apply(lambda x: str(x) if isinstance(x, list) else x)
        self.df.to_csv(self.data_file, index=True)
pass  # Adding this for consistency

#--reminder--
def send_reminder(user, reminder_text, reminder_time):
  import random
import time
import datetime

def daily_reminder():
    """
    Sends a daily reminder with motivational quotes and messages
    in the morning and evening.
    """

    quotes = [
        "The only way to do great work is to love what you do. - Steve Jobs",
        "Believe you can and you're halfway there. - Theodore Roosevelt",
        "The difference between ordinary and extraordinary is that little extra. - Jimmy Johnson",
        "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
        "Success is not final, failure is not fatal: it is the courage to continue that counts. - Winston Churchill",
        "Don't be afraid to give up the good to go for the great. - John D. Rockefeller",
        "The mind is everything. What you think you become. - Buddha",
        "The only person you are destined to become is the person you decide to be. - Ralph Waldo Emerson",
        "Life is 10% what happens to me and 90% of how I react to it. - Charles Swindoll",
        "The only thing that stands between you and your dream is the will to try and the belief that it is actually possible. - Joel Brown"
    ]

    messages = [
        "Remember to take breaks and stay hydrated during your study sessions.",
        "Don't be afraid to ask for help if you're struggling with a concept.",
        "Celebrate your small victories and stay motivated!",
        "Believe in yourself and your ability to succeed.",
        "You've got this! Keep pushing towards your goals."
    ]

    # Get the current time
    now = datetime.datetime.now()

    # Check if it's 8:00 AM or 8:00 PM (you can adjust the times)
    if (now.hour == 8 and now.minute == 0) or \
        (now.hour == 20 and now.minute == 0):  # 20 represents 8:00 PM

        # Indent the following lines to be part of the if block
        quote = random.choice(quotes)
        message = random.choice(messages)

        # Print the reminder
        print("\n--- Daily Reminder ---")
        print(quote)
        print(message)
        print("Don't give up on your dreams! Keep studying and you'll achieve them.")
        print("---\n")



# --- Study Room ---
def enter_study_room(user):

 class User:
    def __init__(self, username):
        self.username = username
        self.study_time = 0
        self.badges = []
        self.points = 0

class StudySession:
    def __init__(self, room_name, duration):
        self.room_name = room_name
        self.duration = duration
        self.participants = []

    def add_participant(self, user):
        self.participants.append(user)

    def end_session(self):
        for user in self.participants:
            user.study_time += self.duration
            # Award points based on study time
            user.points += self.duration * 10  # Example: 10 points per minute
            # Check for badge achievements
            if self.duration >= 60:  # Example: Award "Focus Master" badge for 60+ minutes
                user.badges.append("Focus Master")

# Leaderboard Logic (simplified):
def update_leaderboard(users):
    leaderboard = sorted(users, key=lambda user: user.study_time, reverse=True)
    pass  # Adding this for consistency

# --- Main function ---
def main():
    user = handle_authentication()
    conduct_quiz(user)

    field = input("Enter your field of study: ")  # Get field and subfield for skill recommendation
    subfield = input("Enter your subfield: ")
    recommend_skills(field, subfield)

    num_units = int(input("Enter the number of units: "))  # Get number of units for file organizer
    create_study_folders(num_units)

    setup_scheduler(user)
    schedule_thread = threading.Thread(target=run_schedule_in_background, daemon=True)
    schedule_thread.start()

    start_timer(user)
    predict_grades(user)
    display_dashboard(user)
    enter_study_room(user)
import os
from google.colab import files
import pickle

# ... (Your existing functions: sign_in, learning_style, file_organizer, scheduler) ...

# Model-related functions (moved to the end)
def load_models():
    """Loads the skill and career recommendation models."""
    # ... (Your existing model loading logic) ...

def get_career_skill_recommendations(user_input, skill_model, career_model):
    """Gets career and skill recommendations."""
    # ... (Your existing prediction logic) ...

def load_grades_model():
    """Loads the grades prediction model."""
    # ... (Your grade model loading logic) ...

def get_grade_predictions(user_input, grades_model):
    """Gets grade predictions."""
    # ... (Your grade prediction logic) ...

# Main execution block
if __name__ == "__main__":
    from google.colab import output
    output.eval_js('new Promise(resolve => setTimeout(resolve, 1000));')

    # 1. Sign-in
    if not sign_in():
        print("Sign-in failed. Exiting.")
        exit()

    # 2. Learning Style
    learning_style_result = learning_style()
    print("Your learning styleler()

    # 5. Career and Skill Recommender (moved here)
    skill_model, career_model = load_models()
    user_input_career_skill = input("Enter your information for career and skill recommendations: ")
    career_recommendations, skill_recommendations = get_career_skill_recommendations(user_input_career_skill, skill_model, career_model)
    print("Career Recommendations:", career_recommendations)
    print("Skill Recommendations:", skill_recommendations)

    # 6. Grade Predictor (moved here)
    grades_model = load_grades_model()
    user_input_grades = input("Enter your information for grade prediction: ")
    grade_predictions = get_grade_predictions(user_input_grades, grades_model)
    print("Grade Predictions:", grade_predictions)

